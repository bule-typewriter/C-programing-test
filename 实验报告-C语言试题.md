# 实验报告-C语言试题

## 实验目的

在虚拟机环境中完成以下任务，包括安装操作系统、配置网络、编译与运行C语言代码，并撰写实验报告。

> 来自考核题目内容

## 实验环境

- 主机
  - CPU型号：Intel Core i7-10510U

- 虚拟机（VMware、Ubuntu）
  - 内存：4GB

  - 处理器：2核

  - 硬盘：20GB

## 实验过程

### 实验过程预览：

- 编写程序前置准备

  - 虚拟机VMware安装

  - Ubuntu安装

  - 网络连接测试

  - GCC安装（顺便装了vim）

  - 学习基础Linux命令

  - 学习如何在虚拟机使用GCC

- 编写程序、测试并收集数据

  - 编写生成测试数据脚本

  - 编写测试数据收集脚本

  - 学习快排和归并排序的算法思想及代码实现

  - 编写多种类型排序程序，测试并收集数据

  - 深入代码尝试优化排序程序

  - 使用不同等级GCC编译优化选项

  - 分析算法时间复杂度
  - 学习如何用单核模拟多核

- 撰写实验报告并上传

  - 学习使用矢量图进行数据可视化

  - 学习使用markdown

  - 撰写实验报告

  - 学习使用Typora其他语法美化实验报告

  - 注册Github账号并创建仓库

  - 将实验报告和源代码上传至Github仓库

  - 提交PDF和仓库链接

    

### 编写程序前置准备



#### 安装虚拟机VMware

一开始尝试在官网直接下载，但发现下载速度太慢，需要几天，于是在CSDN找到了好心人在百度网盘分享的资源。

#### 安装Ubuntu

同样是下载速度太慢的问题，于是在镜像网站下载。安装完成后在虚拟机配置好了操作系统。



![](C:\Users\11225\Pictures\Screenshots\屏幕截图 2025-10-22 141027.png)

同时也是第一次了解Linux操作系统，对通过命令行执行程序的特点感到新奇。

```
#唤出终端
ctrl+alt+t
```





#### 网络连接测试

 通过ai给出的命令进行网络连通性检查，后续操作中网络没有问题

![image-20251022150831549](C:\Users\11225\AppData\Roaming\Typora\typora-user-images\image-20251022150831549.png)



#### gcc安装并测试

输入下面的代码进行安装

```sh
# 更新系统包列表（确保获取最新版本信息）
sudo apt update

# 安装 GCC
sudo apt install gcc

# 安装完成后验证
gcc --version
```



以下是实操



![image-20251022142131714](C:\Users\11225\AppData\Roaming\Typora\typora-user-images\image-20251022142131714.png)



我的虚拟机一开始没有vim导致后面编写程序时遇到困难，通过ai一步一步排查知道原因后安装了。



#### 学习基础Linux命令

```sh
#查看自己当前位置
ls

#创建文件夹
mkdir 文件夹名

#进入文件夹
cd 文件夹名

#编写文件
vim 文件名.后缀
```

#### 学习如何在虚拟机使用GCC

我开始尝试编写一个程序，从典型的hello world开始。

1. 创建文件helloworld.c
2. 编写程序
3. 在终端输入命令行`gcc sort_program.c -o sort_program`进行编译
4. 编译后输入命令行`./sort_program`运行
5. 运行成功





### 编写程序、测试并收集数据



#### 编写生成测试数据脚本

通过以下代码实现随机测试数据生成

```c
unsigned int seed = time(NULL);
for (int i = 0; i < n; i++) {
    seed = (seed * 1103515245 + 12345) & 0x7FFFFFFF;
    arr[i] = seed % max_value;
```

随后将数据存储进一个临时文件。

将其作为头文件在排序函数引用，具体代码内容上传至Github。



实际在此之前，我并不知道C语言可以读写文件，在实践操作中我学习到了相关知识。





#### 快速排序



##### 学习快排的算法思想

快排，就是在数组中选择一个数，然后将其他数与之对比，小的和大的放两边，完成一次分区。之后对两个区再进行此操作，不断循环进行下去，直到完成排序。利用了分治算法的思想。

但具体代码实现有很多优化空间，比如

> 挖空法与交换法
>
> 三数取中与随机pivot
>
> 用数组存储与用结构体存储
>



##### 编写多种类型排序程序，测试并收集数据

1. 使用挖空法与交换法，性能有多少差异。

由于一些因素，自己从10.20晚上开始看考核题，导致很多数据测试只能在课堂测试，因此使用的是手机而不是gcc编译器，因此数据的可信度有待确认。数据如下图所示。

> 差异 =（ 随机/三数取中 - 1）*100%

|      | 挖空法（秒） | 交换法（秒） | 差异（%） |
| :--: | :----------: | :----------: | :-------: |
|  1   |    2.750     |    3.644     |   32.49   |
|  2   |    3.450     |    3.689     |   6.93    |
|  3   |    3.446     |    3.658     |   6.15    |
|  4   |    3.443     |    3.663     |   6.39    |
|  5   |    3.444     |    3.659     |   6.24    |
|  6   |    3.456     |    3.675     |   6.34    |
|  7   |    3.440     |    3.662     |   6.46    |
|  8   |    3.434     |    3.653     |   6.38    |
| 平均 |    3.377     |    3.662     |   9.23    |

深入代码细节，发现交换法要进行的赋值操作几乎是挖空法的三倍，有可能因此导致性能差异。但同时我发现性能差异非常小，这是否意味着电脑赋值操作耗时很少，与赋值操作相比，程序会花更多时间在数值的比较操作上吗。

另一点为什么第一次的测试数据差距这么大，在多次的测试中都有这样的规律，认为是CPU缓存的问题



2. 使用三数取中与随机pivot

测试数据量为1000000，数据范围为1-100000

测试结果如下图

> 差异 =（ 随机/三数取中 - 1）*100%

|                |   1    |   2    |    3    |    4    |   5    |
| :------------: | :----: | :----: | :-----: | :-----: | :----: |
|   随机（ms）   | 394.36 | 483.70 | 405.12  | 370.78  | 420.24 |
| 三数取中（ms） | 379.31 | 298.87 | 511.39  | 477.58  | 270.59 |
|   差异（%）    | 3.967  | 61.842 | -20.780 | -22.364 | 55.304 |



3. 使用数组存储与用结构体存储

|      测试次数       |   1   |   2   |   3   |   4   |   5   |   6   |
| :-----------------: | :---: | :---: | :---: | :---: | :---: | :---: |
| 结构体时间/数组时间 | 3.48% | 0.19% | 0.06% | 1.29% | 0.94% | 1.16% |

由图表可知，性能差异很小，有可能是其他因素导致。



##### 使用不同等级gcc编译优化选项



统计收集的数据

| gcc编译优化等级 |   -O0   |   -O1   |   -O2   |   -O3   | -Ofast  |
| :-------------: | :-----: | :-----: | :-----: | :-----: | :-----: |
|    平均耗时     | 0.2990s | 0.2220s | 0.1654s | 0.1553s | 0.1306s |

下图是运行截图

![image-20251022212225435](C:\Users\11225\AppData\Roaming\Typora\typora-user-images\image-20251022212225435.png)

![image-20251022212309507](C:\Users\11225\AppData\Roaming\Typora\typora-user-images\image-20251022212309507.png)

![image-20251022212351769](C:\Users\11225\AppData\Roaming\Typora\typora-user-images\image-20251022212351769.png)

![image-20251022212431842](C:\Users\11225\AppData\Roaming\Typora\typora-user-images\image-20251022212431842.png)

![image-20251022212519153](C:\Users\11225\AppData\Roaming\Typora\typora-user-images\image-20251022212519153.png)



##### 分析算法时间复杂度



分区操作时间复杂度

- 第1层：分区操作需要 O(n) 时间

- 第2层：2个子数组，每个需要 O(n/2)，总共 O(n)
- 第3层：4个子数组，每个需要 O(n/4)，总共 O(n)
- ...
- 每层总工作量都是 O(n)

分区次数复杂度

- 理想情况下O(log n)，故总时间复杂度O(nlog n)
- 最坏情况下O(n)，故总时间复杂度O(n²)



**综合比较表：**

| 特性           | 递归快速排序    | 非递归快速排序  | 随机pivot  | 三数取中pivot |
| :------------- | :-------------- | :-------------- | :--------- | :------------ |
| 平均时间复杂度 | O(n log n)      | O(n log n)      | O(n log n) | O(n log n)    |
| 最坏时间复杂度 | O(n²)           | O(n²)           | O(n²)      | O(n²)         |
| 最坏情况概率   | 取决于pivot选择 | 取决于pivot选择 | 很低       | 极低          |
| 空间复杂度     | O(log n)        | O(log n)        | O(log n)   | O(log n)      |
| 对已排序数据   | 表现差          | 表现差          | 表现良好   | 表现优秀      |
| 实现复杂度     | 简单            | 中等            | 简单       | 中等          |
| 稳定性         | 不稳定          | 不稳定          | 不稳定     | 不稳定        |

#### 归并排序

##### 学习归并排序的算法思想

```c
// 归并排序：先分后治
void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int mid = (l + r) / 2;      // 1. 简单分解（按位置）
        mergeSort(arr, l, mid);     // 2. 递归排序左半
        mergeSort(arr, mid+1, r);   // 3. 递归排序右半
        merge(arr, l, mid, r);      // 4. 合并结果
    }
}
```

运用分治算法思想，先分解数组后进行排序。



##### 编写程序，测试并收集数据



##### 分析算法时间复杂度

归并排序时间复杂度

## 总结

快排运用分治算法思想，是经典的排序算法。对于具体的代码实现，有不同的策略，对于随机数据排序，时间复杂度都为O(nlog n)。

归并排序同样运用分治算法思想，但与快排相比，更适合并行化，更稳定。大部分情况时间复杂度为O(nlog n).

> 总结为下图
>

| 场景         | 归并排序   | 快速排序     |
| :----------- | :--------- | :----------- |
| 已排序数据   | O(n log n) | 可能O(n²)    |
| 随机数据     | O(n log n) | O(n log n)   |
| 逆序数据     | O(n log n) | 可能O(n²)    |
| 大量重复元素 | O(n log n) | 可能性能下降 |



#### 结语：

我在两年前高考期间开始接触电脑的，几乎只有寒暑假可以碰一下电脑，与很多人想比我似乎是一个原始人。在考核的开始我几乎所有的要求都不会，vmware，gcc，Linux，github，虚拟机，矢量图，markdown从来没有听说过，两天的时间里，我每一步都要从入门开始学，但是在学习过程中我发现自己进步很快，这就是实践中学习的优点。

作为新手，学习过程中我经常遇到了这样那样的问题，焦头烂额。但是研究排序算法给了我不少慰藉，修改每一次细节，观察性能变化。实际上给了我不少乐趣。研究这样的程序，既要深入计算机运行指令的每一处具体细节，也要分析抽象的数学思考。

我喜欢其中的乐趣 也享受这个过程

在以后的学习中 希望能做到知其然也知其所以然



*---考生：肖源泰*
